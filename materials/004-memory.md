# Управление памятью

# Какие типы памяти существуют? Где могут храниться экземпляры ссылочных и значимых типов?

В CLR существуют два основных типа памяти для хранения экземпляров типов: стэк и управляемая куча.  

**Стэк** - это быстрая память, которая используется для хранения значения экземпляров значимых типов и ссылок на экзепляры ссылочных типов в куче, во время выполнения методов.  
Под стэк резервируется сегмент оперативной памяти, не нужно путать со стэком процессора.  

**Управляемая куча** - это память, которая используется для хранения экзепляров ссылочных типов и упакованных значимых.  
Существует три управляемых кучи:
- **Small Object Heap (SOH)** - куча маленьких объектов или просто куча. Используется для хранения экземпляров ссылочных типов, которые не хранятся в других кучах.
- **Large Object Heap (LOH)** - куча больших объектов. Используется для хранения экземпляров ссылочных типов размером более 85000 байт и массивов `double` размером больше 1000 элементов. 
- **Pined Object Heap (POH)** - куча закрепленных объектов. Используется для хранения экзепляров закрепленных объектов. Нужна для повышения производительности при работе с ними. Для собеседования достаточно знать этого. 

## Что есть у объекта при хранении в памяти кроме его полей и свойств?

Экземпляр ссылочного тип помимо основных данных имеет дополнительную информацию: указатель на таблицу виртуальных методов (Type Handle) и индекс блока синхронизации (Sync Block Index). Каждый из них занимает дополнительную память равную размеру указателя ([IntPtr](https://learn.microsoft.com/ru-ru/dotnet/api/system.intptr)) в операционной системе: 4 байта в x32 и 8 байт в x64. 

Указатель на таблицу виртуальных методов позволяет определить, экземпляром какого типа является объект хранящийся в куче. Благодаря ему можно наследовать ссылочные типы. 

Индекс блока синхронизации используется для синхронизации во время блокировок. Именно он позволяет вызывать `lock` на экземплярах ссылочного типа. 

[DotNetBook: Структура объектов в памяти](https://dotnetbook.readthedocs.io/ru/latest/ObjectsStructure/)


## Сколько поколений существует в Small Object Heap (SOH)

Существует три поколения второе, первое и нулевое. В памяти они располагаются слева направо от большего к меньшему с начала сегмента. 

|| 2 поколение | 1 поколение | 0 поколение | память доступная для расширения 0 поколения ||

Поколения нужны для оптимизации сборки мусора: выполнить сборку в части кучи быстрее, чем во всей куче. После выполнения цикла сборки несобранные объекты перемещаются в следующее поколение. Движение всегда идет влево, т. е. из 0 в 1, из 1 во 2.  

Экземпляры новых объектов создаются в нулевом поколении. Если памяти недостаточно в нулевом поколении недостаточно, выполняются следующие шаги. При успешном выполнении шага, следующий не выполняется.
1. Начинается сборка мусора. 
2. CLR расширяет поколение при наличии доступной памяти.
3. Если доступной памяти нет, бросается `OutOfMemoryException` и приложение завершается.

В 0 поколении всегда находятся объекты не пережившие сборку мусора. Во втором поколении находятся долгоживущие объекты, которые пережили две сборки мусора. С большой вероятностью они будут существовать всё время жизни приложения.

## Зачем нужен Large Object Heap (LOH)? 

**LOH** - это специальная область памяти для хранения больших объектов более 85000 байт и массивы `double` размером больше 1000 элементов.  
LOH нужна для повышения производительности при работе с большим объектами в памяти.

### Чем Large Object Heap отличается от Small Object Heap (SOH)?

В LOH нет поколений.  
LOH не сжимается автоматически для повышения производительности (отсутствует сжатие при сборке мусора): двигать большие объекты дорого. Можно выполнить сжатие вручную.

# Что такое сборщик мусора?


# Что такое финализатор (Finalizer)?

**Финализатор** - это инструмент, который позволят освобождать неуправляемые ресурсы. 
**Неуправляемый ресурс** - это ресурс, который использует неуправляемую память. Например, файловый дескриптор, соединение с базой данных, tcp соединение и т. д.

Если объект содержит в себе член, который является неуправляемым ресурсом, GC не сможет собрать этот объект, пока ресурс не будет освобожден. Это приведет к утечкам памяти, потому что экземпляры объектов не будут собираться из GC.

Для того, чтобы объявить финализатор нужно использовать следующий синтаксис:
```csharp
public class MyClass
{
    ~MyClass()
    {
        // Логика по освобождению неуправляемых ресурсов
    }
}
```

Используется имя класса с ~ в начале.

## Как работает финализатор?

Финализация выполняется после сборки мусора. 

При создании объекта, реализующего финализатор, через оператор `new` указатель но объект помещается в список финализации (finalization list) - внутреннюю структуру данных, управляемую сборщиком мусора. Каждая запись из списка указывает на объект, для которо нужно вызвать метод финализации, перед освобождения занятой им памяти.

              Корни приложения 
            /                \    
        || obj1 | obj2, obj3, obj4, obj5, obj6 || - Управляемая куча
                                \        /
        Список финализации - || obj4, obj6 ||    ||   || - Очередь финализации
                                 
Сборщик мусора определяет, что объекты obj2, obj3, obj5, obj6 - это мусор, так как на них не ссылаются корни приложения. Далее выполняется поиск указателя на эти объекты в списке финализации. Найденные указатели удаляются из списка финализации и перемещается в очередь финализации (freachable queue), которая управляется CLR.

                        Корни приложения 
                        /      |              
                    || obj1 | obj4, obj6 || - Управляемая куча
                              /        \
    Список финализации - || obj4 ||  || obj6 || - Очередь финализации

obj2, obj3, obj5 были удалены, так как на них нет ссылок из корней приложения, и у них нет финализаторов. Память объекта obj6 освободить нелья, так как его метод финализации еще не вызывался. После перемещения указателя из списка финализации в очередь финализации этот объект перестает считаться мусором и сборщик мусора не может его удалить. Как будто на него ссылается корень приложения.

После помещения объектов в очередь финализации специальный высокоприоритетный поток, выделенный CLR, активизируется и последовательно удаляет элементы из очереди, вызывая методы финализации. При пустой очереди финализации этот поток бездействует. Такой поток существует в единственном экземпляре для того чтобы предотвратить возможные проблемы синхронизации.

При следующем проходе сборщика мусора объекты, которые были финализированы из очереди, становяться мусором. Поэтому сборщик мусора просто удаляет их. **Важно понимать, что для сборки финализируемых объектов необходимо минимум 2 прохода сборщика мусора: первый для помещения в очередь финализации, второй для сборки финализированного объекта.**

                        Корни приложения 
                        /      |              
                    || obj1 | obj4 || - Управляемая куча
                              /        
    Список финализации - || obj4 ||  ||  || - Очередь финализации

# Что такое паттерн Disposable? В чем отличие от финализатора?
  
Паттерн `Disposable` служит той же цели, что и финализатор, но позволяет управлять моментом, когда неуправляемые ресурсы будут освобождены.
Для его реализации существует интерфейс `IDisposable` и его асинхронный аналог `IAsyncDisposable`:
```csharp
/// <summary>Provides a mechanism for releasing unmanaged resources.</summary>
public interface IDisposable
{
  /// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
  void Dispose();
}

/// <summary>Provides a mechanism for releasing unmanaged resources asynchronously.</summary>
public interface IAsyncDisposable
{
  /// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources asynchronously.</summary>
  /// <returns>A task that represents the asynchronous dispose operation.</returns>
  ValueTask DisposeAsync();
}
```

Когда тип реализует `IDisposable` в реализации метода `Dispose` должна быть реализована логика освобождения неуправляемых ресурсов.
```csharp
public class MyGreatClass : IDisposable
{
    private IDbConnection _connection;

    public Dispose()
    {
        // Закрываем соединение, если оно не закрыто
        if(_connection.State != ConnectionState.Closed)
        {
            _connection.Close();
        }        
        
        // Освобождаем ресурсы соединения с БД
        _connection.Dispose();
    }
}
```

Существует комбинированный метод освобождения ресурсов, когда используют и финалайзер и Disposable паттерн.
```csharp
public class MyGreatClass: IDisposable
{
    private bool _disposed = false;

    private IDbConnection _connection;

    public void Dispose()
    {
        // Освобождаем неуправляемые ресурсы. 
        // При вызове Dispose(bool disposing) из метода Dispose() передается аргумент true, который указывает на то, что освобождение ресурсов выполняется разработчиком.
        // Это означает, что может быть необходимость очистить управляемые ресурсы внутри класса MyGreatClass. Для этого в методе Dispose(bool disposing) есть блок if(disposing).
        Dispose(true);
        // Подавляем финализацию экземпляра. После вызова этого метода финализатор не будет вызван.
        GC.SuppressFinalize(this);
    }
 
    // В случае вызова из Dispose() метод освобождает управляемые и неуправляемые ресурсы
    // В случае вызова из ~MyGreatClass() метод освобождает только неуправляемые ресурсы
    protected virtual void Dispose(bool disposing)
    {   
        // Ничего не делаем, если уже был выполнен вызов метода Dispose();
        if (_disposed) 
            return;
        
        if (disposing)
        {
            // Освобождаем управляемые ресурсы
        }
        
        // Освобождаем неуправляемые ресурсы:
        // Закрываем соединение, если оно не закрыто
        if(_connection.State != ConnectionState.Closed)
        {
            _connection.Close();
        }        
        
        // Освобождаем ресурсы соединения с БД
        _connection.Dispose();

        // Проставляем флаг, что Dispose() уже был выполнен.
        disposed = true;
    }
 
    // Финалайзер
    ~MyGreatClass()
    {
        // При вызове Dispose(bool disposing) из финалайзера передается аргумент false, который указывает на то, что освобождение ресурсов выполняется средой выполнения.
        // Это означает, что выполнять очистку управляемых ресурсов не нужно, потому что они уже могут быть уничтожены. Например, зависимые объекты собраны сброщиком мусора. 
        // Поэтому такой метод выполняет освобождение только неуправляемых ресурсов.
        Dispose(false);
    }
}
```
Главное преимущество такого подхода заключается в том, что если разработчик забудет вызвать `Dispose()` на экземпляре объекта, очистка все равно будет выполнена, так как есть финалайзер.

## Для чего нужно ключевое слово using?

**using** - это синтаксический сахар для упрощения использования паттерна Disposable.

using разворачивается компилятором в блок try - finally. 
```csharp
using(var disposableObject = new DisposableObject())
{
    // Какая-то логика
}
``` 
Код выше эквивалентен следующему
```csharp
DisposableObject disposableObject = new DisposableObject();
try
{
    // Какая-то логика
}
finally
{
    if (disposableObject != null)
    {
        ((IDisposable)disposableObject).Dispose();
    }
}
```